#include <iostream>
#include <string>
#include <iomanip>
#include <parth/parth.h>
#include <CLI/CLI.hpp>
#include <Eigen/Core>
#include <Eigen/Sparse>
#include <unsupported/Eigen/SparseExtra>

/*
 * PARTH Quick Start Example: Demonstrating Computational Reuse
 * 
 * This example demonstrates how PARTH efficiently reuses computations when 
 * processing matrices with similar sparsity patterns. The key benefit is that
 * when you have a matrix that changes slightly (e.g., mesh refinement, small
 * topology changes), PARTH can reuse previous computations to dramatically
 * speed up the permutation calculation.
 * 
 * Workflow:
 * 1. Load original matrix and compute initial permutation (full computation)
 * 2. Load modified matrix with different sparsity entries
 * 3. Compute permutation for modified matrix (reuses previous computations)
 * 
 * The matrices used here are generated by the example_creator tool, where:
 * - original_matrix.mtx: Base matrix from a mesh
 * - 2_matrix.mtx: Same matrix with additional edges/entries added
 */

int main(int argc, char *argv[]) {
    
    // ========================================================================
    // STEP 1: Load the Original Matrix
    // ========================================================================
    std::cout << "STEP 1: Loading original matrix..." << std::endl;
    std::cout << "This is the base matrix from which we'll compute the initial permutation." << std::endl;
    
    Eigen::SparseMatrix<double> original_matrix;
    std::string original_matrix_path = "/Users/behrooz/Desktop/LastProject/Parth/tests/matrices/original_matrix.mtx";
    if (!Eigen::loadMarket(original_matrix, original_matrix_path)) {
        std::cerr << "Failed to load original matrix from: " << original_matrix_path << std::endl;
        return 1;
    }
    std::cout << "âœ“ Original matrix loaded successfully." << std::endl;
    std::cout << "  Size: " << original_matrix.rows() << "x" << original_matrix.cols() 
              << ", Non-zeros: " << original_matrix.nonZeros() << std::endl;

    // ========================================================================
    // STEP 2: Load the Modified Matrix (with Different Sparsity Pattern)
    // ========================================================================
    std::cout << "\nSTEP 2: Loading modified matrix..." << std::endl;
    std::cout << "This matrix has the same structure as the original but with additional" << std::endl;
    std::cout << "non-zero entries, simulating mesh refinement or topology changes." << std::endl;
    
    Eigen::SparseMatrix<double> matrix_1;
    std::string matrix_1_path = "/Users/behrooz/Desktop/LastProject/Parth/tests/matrices/2_matrix.mtx";
    if (!Eigen::loadMarket(matrix_1, matrix_1_path)) {
        std::cerr << "Failed to load modified matrix from: " << matrix_1_path << std::endl;
        return 1;
    }
    std::cout << "âœ“ Modified matrix loaded successfully." << std::endl;
    std::cout << "  Size: " << matrix_1.rows() << "x" << matrix_1.cols() 
              << ", Non-zeros: " << matrix_1.nonZeros() << std::endl;
    
    int additional_entries = matrix_1.nonZeros() - original_matrix.nonZeros();
    std::cout << "  Additional entries: " << additional_entries << " (+" 
              << std::fixed << std::setprecision(1) 
              << (100.0 * additional_entries / original_matrix.nonZeros()) << "%)" << std::endl;

    // ========================================================================
    // STEP 3: Initialize PARTH and Compute Initial Permutation
    // ========================================================================
    std::cout << "\nSTEP 3: Computing permutation for original matrix..." << std::endl;
    std::cout << "This is the initial computation - PARTH will build its internal" << std::endl;
    std::cout << "data structures and compute the permutation from scratch." << std::endl;
    
    PARTH::ParthAPI parth;
    
    // Set the original matrix structure in PARTH
    // Parameters: rows, column pointers, row indices, dimension (1 for scalar problems)
    parth.setMatrix(original_matrix.rows(),
                    const_cast<int*>(original_matrix.outerIndexPtr()), 
                    const_cast<int*>(original_matrix.innerIndexPtr()), 1);
    
    std::vector<int> perm;
    parth.computePermutation(perm);
    
    std::cout << "âœ“ Initial permutation computed (no reuse possible yet)." << std::endl;
    std::cout << "  Permutation size: " << perm.size() << std::endl;
    std::cout << "Timing details:" << std::endl;
    parth.printTiming();

    // ========================================================================
    // STEP 4: Compute Permutation for Modified Matrix (WITH REUSE)
    // ========================================================================
    std::cout << "\nSTEP 4: Computing permutation for modified matrix..." << std::endl;
    std::cout << "Now PARTH will detect similarities with the previous matrix and" << std::endl;
    std::cout << "REUSE computations wherever possible, dramatically speeding up" << std::endl;
    std::cout << "the permutation calculation!" << std::endl;
    
    // Update PARTH with the new matrix structure
    // PARTH automatically detects changes and determines what can be reused
    parth.setMatrix(matrix_1.rows(),
                    const_cast<int*>(matrix_1.outerIndexPtr()), 
                    const_cast<int*>(matrix_1.innerIndexPtr()), 1);

    // Compute the new permutation with computational reuse
    parth.computePermutation(perm);
    
    std::cout << "âœ“ Modified matrix permutation computed WITH REUSE!" << std::endl;
    std::cout << "  Permutation size: " << perm.size() << std::endl;
    
    // Display reuse statistics
    double reuse_percentage = parth.getReuse();
    int num_changes = parth.getNumChanges();
    std::cout << "\nðŸš€ REUSE STATISTICS:" << std::endl;
    std::cout << "  Computational reuse: " << std::fixed << std::setprecision(1) 
              << (reuse_percentage * 100.0) << "%" << std::endl;
    std::cout << "  Number of changes detected: " << num_changes << std::endl;
    
    std::cout << "\nTiming details (with reuse):" << std::endl;
    parth.printTiming();

    // ========================================================================
    // SUMMARY
    // ========================================================================
    std::cout << "\n" << std::string(70, '=') << std::endl;
    std::cout << "SUMMARY: PARTH Computational Reuse Demo" << std::endl;
    std::cout << std::string(70, '=') << std::endl;
    std::cout << "1. âœ“ Loaded original matrix (" << original_matrix.nonZeros() << " entries)" << std::endl;
    std::cout << "2. âœ“ Loaded modified matrix (" << matrix_1.nonZeros() << " entries)" << std::endl;
    std::cout << "3. âœ“ Computed initial permutation (full computation)" << std::endl;
    std::cout << "4. âœ“ Computed modified permutation with " << std::fixed << std::setprecision(1) 
              << (reuse_percentage * 100.0) << "% reuse!" << std::endl;
    std::cout << "\nThis demonstrates PARTH's ability to efficiently handle" << std::endl;
    std::cout << "evolving matrices in applications like adaptive mesh refinement," << std::endl;
    std::cout << "topology optimization, and incremental simulations." << std::endl;
    std::cout << std::string(70, '=') << std::endl;

    return 0;
}